name: inverse
layout: true
class: center, middle, inverse

---

.percent120[.center[![bg](img/dogfooding.png)]]

# 從 API 角度思考／<br/>環境變數與 Linking

???

Img src: http://webblocks.co/dogfood

---

layout: false

# Lab setup

.pull-left[
## VMs

1. `main`:
   - `up`
   - `ssh`

2. `registry`:
   - `up`
]


.pull-right[
## Lab directory
- `build-redis`
]

---

class: center, middle

# 回顧 - Lab #6 的例子
## 【性能評比／與 Native Process 比較】

---

# Task 2B: Docker version

啟動 Redis server：

```bash
$ docker run -d  --name redis  \
    -v $(pwd):/data            \
    williamyeh/redis:2.8.19  start
```
--

跑 benchmark：

```bash
$ docker run --rm       \
    --link redis:redis  \
    williamyeh/redis:2.8.19  benchmark
```
--

### ... What are these `start` and `benchmark`?

<br/>
☛ Let's take a look at source code: https://github.com/William-Yeh/docker-redis

---

# Dockerfile as a spec...

`Dockerfile`, near the end:

```dockerfile
#...

# configure Redis
VOLUME  [ "/data", "/etc/redis" ]

# Redis port.
EXPOSE  6379

# for convenience
ENV   PATH       /opt:$PATH
COPY  usage.sh   /opt/
COPY  start      /opt/
COPY  client     /opt/
COPY  benchmark  /opt/

# Define default command.
CMD  ["usage.sh"]
```

---

# CMD: Default command

```dockerfile
CMD  [ "usage.sh" ]
```

## ☛ will call this "usage.sh"

  - `docker run ... williamyeh/redis:2.8.19`
--

  - `docker run ... williamyeh/redis:2.8.19  usage.sh`
--

  - `docker run ... williamyeh/redis:2.8.19  /opt/usage.sh`

--

## ☛ will call other scripts

  - `docker run ... williamyeh/redis:2.8.19  start`
  - `docker run ... williamyeh/redis:2.8.19  benchmark`
  - `docker run ... williamyeh/redis:2.8.19  client`

---

# Wrapper Script #1

`usage.sh`:

```bash
#!/bin/bash

cat << EOF
williamyeh/redis - Docker image for Redis.

Env
===
- Exported volumes:
    * [OUT] /data - for Redis persistent data.
    * [IN]  /etc/redis - for customized "redis.conf".

Usage
=====
## Starting a Redis server with my simple wrapper

  Cmd:  start  [config-file]
  Args:
    - config-file: default = redis.conf

  Examples:
...
```

---

# Wrapper Script #2

`start`:

```bash
#!/bin/bash
#
# Simple wrapper for "redis-server" executable.
#
# Usage:  start  [config-filename]
#
# Arguments:
#   - config-filename: default="redis.conf"
#

CONF=${1:-redis.conf}

exec  redis-server  /etc/redis/$CONF
```

`Dockerfile`:

```dockerfile
# configure Redis
VOLUME  [ "/data", "/etc/redis" ]
```

---

# Wrapper Script #3

`client`:

```bash

```


---

# Wrapper Script #4

`benchmark`:

```bash

```

---

class: center, middle

# What the h*ll are these environment variables?

---

template: inverse

# Container Linking

---

## How to access the container that has not port mapping?

For example,

   ```bash
   $ docker run -d  --name redis  \
       -v $(pwd):/data            \
       williamyeh/redis:2.8.19  start
   ```

There's no port mapping:

   ```bash
   $ docker port     redis

   # or, more details:
   $ docker inspect  redis
   ```

---

## Use link to access it...

- Invoke a bash container to **link** to it...

  ```bash
  $ docker run -it  \
        --link redis:redis_srv
        ubuntu:14.04   bash
  ```

  Now, we're inside the bash container, with a tty.

--
- List environment variables in this bash container:

  ```bash
  env
  ```

--
  or, filter "`REDIS_SRV`" (in uppercase) patterns:

  ```bash
  env | grep REDIS_SRV
  ```

---

## Try these environment variables generated by linking...

For example, `REDIS_SRV_PORT_6379_TCP_ADDR`:

```bash
$ docker run -it  --link redis:redis_srv  ubuntu:14.04  \
    bash -c  'echo $REDIS_SRV_PORT_6379_TCP_ADDR'
```

--

`REDIS_SRV_PORT_6379_TCP_PORT`:

```bash
$ docker run -it  --link redis:redis_srv  ubuntu:14.04  \
    bash -c  'echo $REDIS_SRV_PORT_6379_TCP_PORT'
```

---

# Benefits of container linking

- Without specify ports explicitly

--

- Portable addressing

--

- Portable naming

---

template: inverse

# Recap: API Thinking

---

class: center, middle

# Questions?
